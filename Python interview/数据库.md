## 数据库事物
    * 数据库事务是指作为单个逻辑工作单元执行的一系列操作，要么完全的执行，要么完全地不执行

## 数据库索引
    * 聚集索引
    * 非聚集索引
    * B-Tree
    * B+Tree
    * 最左前缀原理

## Redis
    * Redis: key-value内存数据库,通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets

    * 优点: 
      1.速度快:使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万
      2.持久化:Copy-on-write对数据更新，异步保存到磁盘 ->策略:i.根据时间更新次数快照 ii.基于语句追加方式
      3.自动操作:对不同数据类型的操纵都是自动的很安全
      4.快速自-从复制
      5.Sharding技术:数据库扩展，把负载分布到多个特理节点上去的横向扩展

    * 缺点:
      1.数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上
      2.Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费

## 乐观锁和悲观锁
    * 悲观锁:假定会发生并发生冲突，屏蔽一切可能违反数据完整性的操作
    * 乐观锁:假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性

## MVCC
  >全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。
  
----------------------------------------------  
# MySQL    
----------------------------------------------
## 一、存储引擎
----------------------------------------------
### InnoDB
    * InnoDB是MySQL默认的事务型存储引擎，只有在需要InnoDB不支持的特性时才会考虑使用其他存储引擎
    * 采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ),并且通过间隙锁(next-key locking)策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定以及放置幻影行的插入
    * 表是基于聚簇索引建立的，它对主键的查询性能有很高的提升
    * 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够自动在内存中创建哈希索引以加速读操作的自适应哈希索引、能够加速插入操作的插入缓冲区等
    * 通过一些机制和工具支持真正的热备份，其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取

### MyISAM
    * 提供了大量的特性，包括全文索引、压缩表、空间数据索引等。应该注意的是MySQL 5.6.4也添加了对InnoDB引擎的全文索引支持
    * 不支持事务
    * 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取查询的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)
    * 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的
    * 如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作
    * 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以继续使用MyISAM

### InnoDB和MyISAM比较
1. 事务：InnoDB是事务型的
2. 备份：InnoDB支持在线热备份
3. 崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢
4. 并发：MyISAM只支持表级锁，而InnoDB还支持行级锁
5. 其他特性：MyISAM支持压缩表和空间数据索引

----------------------------------------------
## 二、数据类型
----------------------------------------------
### 整型
    * TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT 分别使用8,16,24,32,64位存储空间，一般情况下越小的列越好
    * INT(11)中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的

### 浮点数
    * FLOAT和DOULE为浮点类型，DECIMAL为高精度小数类型。CPU原生支持浮点运算，但是不支持DECIMAL类型的计算，因此DECIMAL的计算比浮点类型需要更高的代价
    * FLOAT、DOUBLE和DECIMAL都可以指定列宽，例如DECIMAL(18,9)表示总共18位，取9位存储小数部分，剩下9位存储整数部分

### 字符串
    * 主要有CHAR和VARCHAR两种类型，一种是定长的，一种是变长的
    * VARCHAR这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行UPDATE时可能会使行变得比原来长，当超出一个页面所能容纳的大小时，就要执行额外的操作。MyISAM会将行拆成不同的片段存储，而InnoDB则需要分裂页来使行放进页内
    * VARCHAR会保留字符串末尾的空格，而CHAR会删除

### 时间和日期
MySQL提供了两种相似的日期时间类型：DATATIME和TIMESTAMP
- DATATIME
    * 能够保存从1001年到9999年的日期和时间，精度为妙，使用8字节的存储空间
    * 它与时区无关
    * 默认情况下，MySQL以一种可排序、无歧义的格式显示DATATIME值，例如"2008-01-16 22:37:08",这是ANSI标准定义的日期和时间表示方法
- TIMESTAMP
    * 和UNIX时间戳相同，保存从1970年1月1日午夜(格林威治时间)以来的秒数，使用4个字节，只能表示从1970年到2038年
    * 它和时区有关
    * MySQL提供了FROM_UNIXTIME()函数把UNIX时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数把日期转换成UNIX时间戳
    * 默认情况下，如果插入时没有指定TIMESTAMP列的值，会将这个值设置为当前
    * 应该尽量使用TIMESTAMP，因为它比DATATIME空间效率更高

----------------------------------------------
## 三、素引
>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。索引能够轻易将查询性能提升几个数量级。对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。对于中到大型的表，索引就非常有效。但是对于特大型的表，建立和使用索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。
----------------------------------------------
### 索引分类
1. B+Tree索引
    * B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。
    * 因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多
    * 可以指定多个列作为索引列，多个索引列共同组成键。B+Tree 索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找
    * 除了用于查找，还可以用于排序和分组
    * 如果不是按照索引列的顺序进行查找，则无法使用索引
2. 哈希索引
    * 基于哈希表实现，优点是查找非常快
    * 在 MySQL 中只有 Memory 引擎显式支持哈希索引
    * InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
    * 限制：哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响并不明显；无法用于分组与排序；只支持精确查找，无法用于部分查找和范围查找；如果哈希冲突很多，查找速度会变得很慢。
3. 空间数据索引（R-Tree）
    * MyISAM 存储引擎支持空间索引，可以用于地理数据存储
    * 空间索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询
    * 必须使用 GIS 相关的函数来维护数据
4. 全文索引
    * MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值
    * 使用 MATCH AGAINST，而不是普通的 WHERE

### 索引的优点
    * 大大减少了服务器需要扫描的数据量
    * 帮助服务器避免进行排序和创建临时表（B+Tree 索引是有序的，可以用来做 ORDER BY 和 GROUP BY 操作）
    * 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，也就将相关的列值都存储在一起）

### 索引优化
1. 独立的列
    * 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引
2. 前缀索引
    * 对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符
    * 对于前缀长度的选取需要根据 索引选择性 来确定：不重复的索引值和记录总数的比值。选择性越高，查询效率也越高。最大值为 1，此时每个记录都有唯一的索引与其对应
3. 多列索引
    * 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好
4. 索引列的顺序
    * 让选择性最强的索引列放在前面
5. 聚簇索引
>聚簇索引并不是一种索引类型，而是一种数据存储方式。术语“聚簇”表示数据行和相邻的键值紧密地存储在一起，InnoDB 的聚簇索引在同一个结构中保存了 B+Tree 索引和数据行,因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引
   - 优点
        *  可以把相关数据保存在一起，减少 I/O 操作。例如电子邮件表可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据也就能获取某个用户的全部邮件，如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O
        * 数据访问更快
    - 缺点
        * 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引。
        * 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的。
        * 更新操作代价很高，因为每个被更新的行都会移动到新的位置。
        * 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间。
        * 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢。
6. 覆盖索引
   * 索引包含所有需要查询的字段的值
   - 优点
        * 因为索引条目通常远小于数据行的大小，所以若只读取索引，能大大减少数据访问量
        * 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）
        * 对于 InnoDB 引擎，若二级索引能够覆盖查询，则无需访问聚簇索引