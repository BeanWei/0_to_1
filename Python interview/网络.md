## 三次握手
    * 客户端通过向服务器发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数A
    * 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机序号B
    * 最后客户端再发送一个ACK，当服务器端收到这个ACK的时候，就完成了三次握手，并进入了连接创建状态。此时包序号被设定为收到的确认号A+1，而响应则为B+1

## 四次挥手
>中断连接端的可以是客户端也可以是服务端，下面仅以客户端断开连接举例反之亦然
* 客户端发送一个数据分段，其中的FIN标记设置为1，客户端进入FIN-WAIT状态，该状态下客户端只接收数据，不再发送数据
* 服务器接收到带有FIN=1的数据分段，发送带有ACK=1的剩余数据分段，确认收到客户端发来的FIN信息
* 服务器等到所有数据传输结束，向客户端发送一个带有FIN=1的数据分段，并进入CLOSE-WAIT状态，等带客户端发来带有ACK=1的确认报文
* 客户端收到服务器发来带有FIN=1的报文，返回ACK=1的报文确认，为了防止服务器端未收到需要重发，进入TIME-WAIT状态，服务器接收到报文后关闭连接，客户端等待2MSL后未收到回复，则认为服务器成功关闭，客户端关闭连接

## 为什么是三次握手而不是两次或者四次？
    * 如果只有两次握手，则此时仅表示server端可接收信息
    * 无需四次的原因是通过三次握手双方已经互相确保了己方和对方都可以正常接收发送信息

## 为什么是四次挥手？
    * 第一次挥手仅代表主动发不会再发送数据报文但仍可以接收数据报文
    * 第二次挥手被动方可能还有数据要传
    * 第三次挥手被动方保证数据传输完成并进入超时等待阶段
    * 第四次挥手主动方收到中断确认，这时被动方就直接释放连接进入可用状态

## ARP协议
    * 地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPV4网络层必不可少的协议，不过在IPV6中已不再适用，并被邻居发现协议(NDP)所替代

## urllib和urllib2的区别
    * urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常常和urllib2一起使用的原因
    * urllib2可以接收一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL

## POST和GET
    * POST body传参，传送完就没了
    * GET URL传参，CDN缓存

## cookie和session
    * cookie存在客户端，不安全
    * session存在服务器端，安全
    * session基于cookie

## apache和nginx的区别
  - nginx相抵apache的有点：
    * 轻量，抗并发，配置简洁，高度模块化编写模块相对简单，社区活跃
  - apache相对nginx的有点：
    * rewrite更强大，模块非常多，bug相对较少，超稳定

## 常见的WEB加密方式
    * Base64
    * 单向散列函数（MD5，SHA1，SHA512）
    * 对称加密
    * 非对称加密
    * 数字签名
    * 数字证书
  [常见的WEB加密方式](https://blog.csdn.net/lendq/article/details/79285412)

## Http和Https
    * HTTP 缺省工作在TCP协议80端口，运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
    * https 是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上，端口为443。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。(加大了服务器开销)
    * HTTPS握手，对称加密，非对称加密，TLS/SSL,RSA

## 状态码和定义
* 1xx 报告              接收到请求，继续进程
* 2xx 成功              步骤成功接收，被理解并被接受
* 3xx 重定向            为了完成请求，必须采取进一步措施
* 4xx 客户端出错        请求包括错的顺序或不能完成
* 5xx 服务器出错        服务器无法完成显然有效的请求 

## CSRF和XSS
    * CSRF 跨站请求伪造(网站过分信任用户，放任来自所谓通过访问控制机制的代表合法用户的请求执行网站的某个特定功能。)
    * XSS 跨站脚本攻击(用户过分信任网站，放任来自浏览器地址栏代表的那个网站代码在自己本地任意执行。如果没有浏览器的安全机制限制，xss代码可以在用户浏览器为所欲为)
    - CSRF重点在请求,XSS重点在脚本
    - 防范XSS:过滤所有的‘<’和‘>’字符，确保从后端而来的数据并不带有任何的html标签，xss的危险在于有不可预料的前端脚本，但是值得注意的是，不单只有script标签是可以运行脚本的，任何的html标签都可以加上类似onclick，onload这样的事件也都可以运行脚本，所以需要过滤所有的‘<’和‘>’字符。
    - 防范CSRF:第一点是对于数据库的更改操作（insert、update和delete），表单必须使用post请求。这是为了防止类似于在一个img和src里面写一个路径，让用户错误访问改动数据库的问题。做完第一点还不够，因为html表单的action是可以跨域提交的，用户在一个网站提交到另一个网站，可能他还不知情，这就需要确保用户的来源表单是可信的，一般的做法是在表单里面添加一段隐藏的唯一的token，像sessionId那样可以验明用户的身份，接收表单的同时确认这个token的有效性。
        *  考虑点：token 如何存储 ， 如何验证 ，何时刷新
   
    - 在Django中的保护措施
        * csrf 的防御主要在 middleware 实现
    - 在Flask中的保护措施
        * 通过Flask-WTF来保护表单免受CSRF攻击

## RESTful架构
    - 什么是RESTful架构(Representational State Transfer的缩写。我对这个词组的翻译是"表现层状态转化"。)
      * 每一个URI代表一种资源
      * 客户端和服务器之间，传递这种资源的某种表现层
      * 客户端通过四个HTTP动词(GET、POST、PUT、DELETE)，对服务器端资源进行操作，实现"表现层状态转化"
   [理解RESTful架构-阮一峰](http://www.ruanyifeng.com/blog/2011/09/restful.html)

## SOAP和RPC
    * SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。
    * RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
    - 进化顺序:  RPC -> SOAP -> RESTful

## CGI 和 WSGI
    * CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据和文件等。CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，lua，python等
    * WSGI(Web Server Gateway Interface-web服务网关接口)，是python应用程序或框架和web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(python)编写前后端

## 中间人攻击
    * 中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制

## C10K 问题
    * 所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）
    * 解决方案：主要思路有两 => 一个是对于每个连接处理分配一个独立的进程/线程；另一个思路是用同一进程/线程来同时处理若干连接。

## Socket
    * Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

## HTTP请求的8种方法
- GET
   * GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

- HEAD
    * HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。

- POST
    * POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

- PUT
    * PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

- DELETE
    * DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。

- CONNECT
    * CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

- OPTIONS
    * OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 

- TRACE
    * TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

- PATCH
    * HTTP/1.1之后增加的方法
    在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：
    PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：
    但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。 当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新

## Ajax
    * AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。